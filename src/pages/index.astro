---
import BaseHead from '../components/BaseHead.astro';
import Footer from '../components/Footer.astro';
import Header from '../components/Header.astro';
import Title from '../components/Title.astro';
import { SITE_DESCRIPTION, SITE_TITLE } from '../consts';
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header />
		<main>
			<section class="index--masthead">
				<h2 class="index--masthead--subhead">The Personal Homepage of Luke Murphy</h2>
				<svg>
					<defs>
						<filter id="distort">
							<feTurbulence baseFrequency="0 0.1" numOctaves="10" result="noise" />
							<feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="20" xChannelSelector="R" yChannelSelector="Y" />
						</filter>
					</defs>
				</svg>
				<svg>
					<defs>
						<filter id="blur">
							<feGaussianBlur in="SourceGraphic" stdDeviation="10,0" />
						</filter>
					</defs>
				</svg>
				<h1 class="index--masthead--head">
					<span class="index--masthead--primary" data-text="Ace ">Ace </span>
					<span class="index--masthead--secondary" data-text="of ">of </span>
					<span class="index--masthead--primary" data-text="Cups">Cups</span>
				</h1>
				<div class="unicorn"></div>
			</section>
			<section class="index--intro">
				<h2 class="scramble small-heading">&lt;intro&gt;</h2>
				<p>This is the personal site (and portfolio) of Luke Murphy, the Australian-cum-British designer, developer, writer, speaker and general reprobate.</p>
				<p>I am currently building this site as I go, so it might be buggy af. Want to follow the progress? Follow me on <a href="https://bsky.app/profile/lurkmoophy.bsky.social">Bluesky</a>.</p>
			</section>
			<section class="aside masthead--aside">
				<h3 class="scramble small-heading">&lt;<span class="emoji">üç∑</span> Why Ace of Cups?&gt;</h3>
				<p>The Ace of Cups is a card of creativity, emotional beginnings, and love. It's a reminder that we all have the ability to create our own reality. As a perpetual side quest starter, I thought it was a pretty good summation of how I want to approach life, even if being a sad little emo sometimes gets in the way.</p>
			</section>
			<section class="index--section">
				<Title title="Manifesto" class="scramble" />
				<div class="manifesto-container">
					<div class="text-container">
						<p class="dropcap">
							Why start a page with a boring about section? Well, this is still a boring about section, but restyled in the form of a manifesto. You possibly want to know a bit more about me, but I also think it‚Äôs  important to share the things you indelibly believe in at the same time.
						</p>
						<p>
							So, let‚Äôs start with the basic stuff to get it out of the way. I‚Äôm a 40-something person who has spent most of their career in some mixture of product design, front-end development, writing and speaking, and carrying on too many side projects to feasibly keep going. My pronouns are they/them (using the correct pronouns makes you a cooler person. Fact), and I currently call Letchworth Garden City, UK my home.
						</p>
						<p>
							I believe in making things for the internet that don‚Äôt suck, both from a ‚Äòputting joy into the world‚Äô point of view, as well as a ‚Äònot making things shitty for people by not thinking about accessibility and inclusivity‚Äô.
						</p>
						<p>
							I believe that trans rights are human rights, that borders shouldn‚Äôt exist, that diversity and equity should be front and centre of most things, and that Josie and the Pussycats is the greatest film of all-time.
						</p>
					</div>
					<div class="manifesto-statements">
						<div class="statement">
							<div class="statement-text" data-text="GENDER CRITICAL VIEWS ARE BIGOTRY">GENDER CRITICAL VIEWS ARE BIGOTRY</div>
						</div>
						
						<div class="statement">
							<div class="statement-text" data-text="BORDERS ARE BULLSHIT">BORDERS ARE BULLSHIT</div>
						</div>
						
						<div class="statement">
							<div class="statement-text" data-text="REFORM UK ARE FASCISTS">REFORM UK ARE FASCISTS</div>
						</div>
						
						<div class="statement">
							<div class="statement-text" data-text="DEI IS ESSENTIAL">DEI IS ESSENTIAL</div>
						</div>
						
						<div class="statement">
							<div class="statement-text" data-text="JOSIE AND THE PUSSYCATS 4LYF">JOSIE AND THE PUSSYCATS 4LYF</div>
						</div>
					</div>
				</div>
			</section>
		</main>
		<style is:global>

			.index--masthead {
				position: relative;
				padding: 0 3rem;
			}
			.index--masthead svg {
				position: absolute;
			}
			.index--masthead--subhead {
				font-size: clamp(1rem, 0.75rem + 1vw, 2rem);
				font-weight: 400;
				text-transform: uppercase;
				text-align: justify;
				text-align-last: justify;
				display: block;
				width: 90%;
				margin: 3rem auto 0;
				letter-spacing: clamp(0.3rem, 0.25rem + 1vw, 0.7rem);
			}
			.index--masthead--head {
				display: flex;
				align-items: center;
				justify-content: center;
				width: 100%;
				line-height: 1;
				flex-wrap: nowrap;
				white-space: nowrap;
				margin: 0.25rem 0 2rem;
			}
			.index--masthead--head span {
				filter: url(#distort);
				position: relative;
			}
			.index--masthead--head span:before {
				content: attr(data-text);
				position: absolute;
				top: 0;
				left: 0;
				filter: url(#blur);
				opacity: 0.5;
				display: block;
				pointer-events: none;
				z-index: -1;
				white-space: nowrap;
			}
			.index--masthead--primary {
				font-family: 'Gideon Roman', serif;
				font-size: clamp(4rem, 1rem + 16vw, 22rem);
				font-weight: 400;
				text-transform: uppercase;
				color: var(--black);
				flex-shrink: 0;
			}
			.index--masthead--secondary {
				font-family: 'Allura', cursive;
				font-size: clamp(4rem, 1rem + 12vw, 10rem);
				font-weight: 400;
				font-style: italic;
				text-transform: lowercase;
				color: white;
				-webkit-text-stroke: 3px var(--black);
				text-stroke: 3px var(--black);
				align-self: center;
				flex-shrink: 0;
				z-index: 2;
				margin-right: 15px;
			}
			.unicorn {
				width: 565px;
				height: 400px;
				background: url('/images/unicorn-sprite.png') no-repeat 0 0;
				background-size: 500% 100%; /* 5 frames = 500% width */
				position: absolute;
				bottom: -230px;
				z-index: 3;
			}
			
			@media (max-width: 1200px) {
				.unicorn {
					width: clamp(300px, 50vw, 565px);
					height: auto;
					aspect-ratio: 565 / 400;
				}
			}

			.index--intro {
				max-width: 31rem;
				margin: 3rem 0 6rem 5%;
			}

			.small-heading {
				font-family: 'Allegreya', serif;
				font-size: 2.25rem;
				font-style: italic;
				font-weight: 300;
			}

			h3.small-heading {
				font-size: 1.5rem;
			}

			.aside {
				background: var(--black);
				color: var(--white);
				border-radius: var(--radius);
				padding: 3rem;
				margin: 2rem auto;
				width: 95%;
				max-width: 600px;
				outline: 4px solid var(--white);
				outline-offset: -20px;
				position: relative;
			}

			.aside p {
				font-size: 1rem;
				line-height: 1.4;
			}

			@media screen and (min-width: 1000px) {
				.aside {
					max-width: 400px;
					margin-right: 10%;
					margin-top: -10rem;
					margin-bottom: -2.75rem;
					z-index: 5;
				}
			}
			

			.manifesto-container {
				display: flex;
				flex-direction: row;
				justify-content: space-between;
				align-items: center;
				max-width: 1300px;
				margin: 0 auto;
				padding: 0 4rem;
			}

			@media (max-width: 1200px) {
				.manifesto-container {
					flex-direction: column;
					align-items: center;
					justify-content: center;
				}
			}

			.manifesto-statements {
				margin-top: 0;
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				max-width: 30rem;
			}

			.statement {
				margin-bottom: 3rem;
				text-align: center;
			}
			
			.statement-text {
				font-family: 'Rakkas', serif;
				font-size: clamp(1.5rem, 1rem + 4vw, 3rem);
				font-weight: 400;
				line-height: 1.1;
				text-transform: uppercase;
				color: var(--black);
				text-align: justify;
				text-align-last: center;
				text-justify: inter-character;
				position: relative;
				word-spacing: 0.2em;
			}

			.statement-text::before {
				content: attr(data-text);
				position: absolute;
				top: 0;
				left: 0;
				opacity: 0.3;
				width: 100%;
				height: 100%;
				filter: url(#blur);
				color: var(--black);
			}
			
			
		</style>
		<style>
			
			.statement-text::after {
				content: '';
				position: absolute;
				bottom: -25px;
				left: 50%;
				transform: translateX(-50%);
				width: 40%;
				height: 2px;
				background-color: var(--black);
			}
			.statement:last-of-type .statement-text::after {
				display: none;
			}

			@media (max-width: 768px) {
				.index--masthead {
					padding: 0;
					width: 100vw;
					margin-left: calc(-50vw + 50%);
					margin-right: calc(-50vw + 50%);
				}
				
				.index--masthead--subhead {
					width: 100%;
					margin: 2rem auto 0;
					text-align: center;
					text-align-last: center;
				}
				
				.index--masthead--head {
					margin: 0.25rem 0 1rem;
					width: 100%;
					position: relative;
				}
				
				.index--masthead--primary {
					font-size: clamp(6rem, 8vw, 8rem);
					position: relative;
					z-index: 3;
				}
				
				.index--masthead--secondary {
					font-size: clamp(4rem, 6vw, 5rem);
					-webkit-text-stroke: 2px var(--black);
					text-stroke: 2px var(--black);
					position: relative;
					z-index: 4;
				}
				
				.unicorn {
					width: 100%;
					max-width: 565px;
					min-width: 150px;
					height: auto;
					aspect-ratio: 565 / 400;
					background-size: 500% 100%; /* 5 frames = 500% width */
					position: relative;
					top: 0;
					bottom: auto;
					margin: -75px auto 0;
					left: auto;
				}
				
				.index--intro {
					margin: 2rem 1rem 4rem;
					max-width: 100%;
				}
				
				.index--intro h2 {
					font-size: 1.75rem;
				}
				
				.manifesto-container {
					padding: 0 1.5rem;
					flex-direction: column;
				}
				
				.text-container {
					max-width: 100%;
					margin-bottom: 2rem;
				}
				
				.manifesto-statements {
					max-width: 100%;
					width: 100%;
				}
				
				.statement-text {
					font-size: clamp(1.5rem, 6vw, 4rem);
				}
				
				.statement {
					margin-bottom: 2rem;
				}
			}
			
			@media (max-width: 480px) {
				.index--masthead {
					padding: 0;
					width: 100vw;
					margin-left: calc(-50vw + 50%);
					margin-right: calc(-50vw + 50%);
				}
				
				.index--masthead--subhead {
					font-size: 0.875rem;
					letter-spacing: 0.2rem;
					margin: 1.5rem auto 0;
				}
				
				.index--masthead--primary {
					font-size: clamp(4rem, 12vw, 6rem);
				}
				
				.index--masthead--secondary {
					font-size: clamp(3rem, 8vw, 4rem);
					-webkit-text-stroke: 1.5px var(--black);
					text-stroke: 1.5px var(--black);
				}
				
				.unicorn {
					width: 100%;
					max-width: 565px;
					min-width: 120px;
					position: relative;
					top: 0;
					bottom: auto;
					left: auto;
				}
				
				.index--intro {
					margin: 1.5rem 1rem 3rem;
				}
				
				.index--intro h2 {
					font-size: 1.5rem;
				}
				
				.manifesto-container {
					padding: 0 1rem;
				}
				
				.statement-text {
					font-size: clamp(1.25rem, 7vw, 3rem);
					word-spacing: 0.1em;
				}
			}
		</style>
		<script is:inline>
			// Simple scroll-based sprite animation without GSAP
			document.addEventListener('DOMContentLoaded', () => {
				const unicorn = document.querySelector('.unicorn');
				const totalFrames = 5;
				
				function updateSprite() {
					if (!unicorn) return;
					
					const scrollTop = window.pageYOffset;
					const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
					
					// Get actual unicorn dimensions (responsive)
					const unicornRect = unicorn.getBoundingClientRect();
					const unicornWidth = unicornRect.width;
					
					// Check if we're on mobile (unicorn is relatively positioned)
					const isMobile = window.getComputedStyle(unicorn).position === 'relative';
					
					// Speed multiplier - higher = faster animation
					const speedMultiplier = 7;
					const scrollProgress = (scrollTop * speedMultiplier) / documentHeight;
					
					// Loop through frames continuously
					const frameProgress = scrollProgress * totalFrames;
					const currentFrame = Math.floor(frameProgress) % totalFrames;
					
					// Calculate background position in pixels
					// With background-size: 500%, the background is 5√ó the element width
					// Each frame is exactly 1√ó the element width
					// So we move by -unicornWidth pixels for each frame
					const backgroundPositionX = -(currentFrame * unicornWidth);
					
					// Update sprite frame
					unicorn.style.backgroundPosition = `${backgroundPositionX}px 0`;
					
					// Only move unicorn horizontally on desktop (absolute positioning)
					if (!isMobile) {
						const scrollPercent = Math.min(scrollTop / documentHeight, 1);
						const screenWidth = window.innerWidth;
						
						// Calculate offset to keep unicorn partially visible
						// Offset is 20px less than unicorn width to keep it partially visible
						const offset = unicornWidth - 20;
						
						// Start at right edge minus offset, end at left edge minus offset
						const startPosition = screenWidth - offset;
						const endPosition = -offset;
						const moveDistance = startPosition - endPosition;
						const currentLeft = startPosition - (scrollPercent * moveDistance);
						
						unicorn.style.left = `${currentLeft}px`;
					} else {
						// On mobile, reset left positioning
						unicorn.style.left = '';
					}
				}
				
				window.addEventListener('scroll', updateSprite);
				window.addEventListener('resize', updateSprite); // Update on resize
				updateSprite(); // Initial call
			});
		</script>
		<script is:inline>
			// Scramble text in elements with .scramble class
			(function() {
				// Wait for GSAP and ScrambleTextPlugin to be available
				function checkAndInit() {
					if (typeof window === 'undefined') return;
					
					if (typeof gsap === 'undefined') {
						setTimeout(checkAndInit, 100);
						return;
					}
					
					// Register GSAP plugins
					if (typeof ScrollTrigger !== 'undefined') {
						gsap.registerPlugin(ScrollTrigger);
					}
					if (typeof ScrambleTextPlugin !== 'undefined') {
						gsap.registerPlugin(ScrambleTextPlugin);
					}
					
					// Wait for DOM to be ready
					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', initScramble);
					} else {
						initScramble();
					}
				}
				
				function createScrambleAnimation(element, textToScramble, scrambleInner, htmlToScramble) {
					// Try to use ScrambleTextPlugin if available, otherwise use custom implementation
					if (typeof ScrambleTextPlugin !== 'undefined') {
						// Use official ScrambleTextPlugin with ScrollTrigger
						gsap.to(scrambleInner, {
							duration: 2,
							scrambleText: {
								text: textToScramble,
								chars: "fwqhiooiwfqhiofwqokljlsdakml",
								revealDelay: 0.5,
								tweenLength: false
							},
							scrollTrigger: {
								trigger: element,
								start: "top 80%",
								toggleActions: "play none none none",
								once: true
							},
							onComplete: function() {
								// Restore HTML if it was provided
								if (htmlToScramble) {
									scrambleInner.innerHTML = htmlToScramble;
								}
							}
						});
					} else {
						// Fallback: Custom scramble effect using GSAP timeline
						// Use uppercase letters that match the original text width
						const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
						
						function getRandomChar() {
							return chars[Math.floor(Math.random() * chars.length)];
						}
						
						function scrambleText(original, progress) {
							let result = '';
							const revealLength = Math.floor(original.length * progress);
							
							for (let i = 0; i < original.length; i++) {
								if (original[i] === ' ') {
									result += ' ';
								} else if (i < revealLength) {
									// Revealed character
									result += original[i];
								} else {
									// Scrambled character
									result += getRandomChar();
								}
							}
							return result;
						}
						
						// Create timeline for scramble effect (no repeat)
						const tl = gsap.timeline({
							scrollTrigger: {
								trigger: element,
								start: "top 80%",
								toggleActions: "play none none none",
								once: true
							}
						});
						
						// Scramble phase
						tl.to({ progress: 0 }, {
							duration: 0.2,
							progress: 1,
							onUpdate: function() {
								scrambleInner.textContent = scrambleText(textToScramble, 0);
							},
							ease: 'none'
						});
						
						// Reveal phase
						tl.to({ progress: 0 }, {
							duration: 0.7,
							progress: 1,
							onUpdate: function() {
								const p = this.progress();
								scrambleInner.textContent = scrambleText(textToScramble, p);
							},
							ease: 'power2.out'
						});
						
						// Hold at full text, then restore HTML if provided
						if (htmlToScramble) {
							tl.set(scrambleInner, { innerHTML: htmlToScramble });
						} else {
							tl.set(scrambleInner, { textContent: textToScramble });
						}
					}
				}
				
				function initScramble() {
					const scrambleElements = document.querySelectorAll('.scramble');
					
					if (scrambleElements.length === 0) {
						console.warn('No elements with .scramble class found');
						return;
					}
					
				// Now process scramble elements
				scrambleElements.forEach((element) => {
					const originalHTML = element.innerHTML;
					
					// Extract content between < and >, preserving HTML
					// Match both &lt;...&gt; (encoded) and <...> (decoded) formats
					// Use a more specific pattern to handle nested HTML tags
					const match = originalHTML.match(/^(?:&lt;|<)(.+?)(?:&gt;|>)$/) || originalHTML.match(/(?:&lt;|<)(.+?)(?:&gt;|>)/);
					
					if (match) {
						// Element has text in <text> format
						const htmlToScramble = match[1]; // The HTML content between < and >
						
						// Get plain text version for scrambling animation
						const tempDiv = document.createElement('div');
						tempDiv.innerHTML = htmlToScramble;
						const textToScramble = tempDiv.textContent || tempDiv.innerText || '';
						
						// Create new structure with brackets and scramble span containing the HTML
						element.innerHTML = '&lt;<span class="scramble-inner">' + htmlToScramble + '</span>&gt;';
						const scrambleInner = element.querySelector('.scramble-inner');
						
						if (!scrambleInner) {
							console.error('Failed to create scramble inner element');
							return;
						}
						
						createScrambleAnimation(element, textToScramble, scrambleInner, htmlToScramble);
						} else {
							// Element is a container - scramble all direct child text elements
							// Skip statement-text elements (no scramble for manifesto statements)
							const childTextElements = element.querySelectorAll('[class*="text"]:not(.statement-text), p, h1, h2, h3, h4, h5, h6');
							
							if (childTextElements.length === 0) {
								// If no specific children found, try to scramble the element's own text
								const textContent = element.textContent.trim();
								if (textContent) {
									// Store original width to prevent layout shifts
									const originalWidth = element.getBoundingClientRect().width;
									if (originalWidth > 0 && element instanceof HTMLElement) {
										element.style.width = `${originalWidth}px`;
										element.style.minWidth = `${originalWidth}px`;
									}
									
									const scrambleInner = document.createElement('span');
									scrambleInner.className = 'scramble-inner';
									scrambleInner.textContent = textContent;
									element.innerHTML = '';
									element.appendChild(scrambleInner);
									createScrambleAnimation(element, textContent, scrambleInner);
								}
								return;
							}
							
							// Set up scramble animation for each element
							childTextElements.forEach((childElement) => {
								const textContent = childElement.textContent.trim();
								if (!textContent) return;
								
								if (!(childElement instanceof HTMLElement)) return;
								
								// Create the scramble inner element
								const scrambleInner = document.createElement('span');
								scrambleInner.className = 'scramble-inner';
								scrambleInner.textContent = textContent;
								childElement.innerHTML = '';
								childElement.appendChild(scrambleInner);
								
								createScrambleAnimation(childElement, textContent, scrambleInner);
							});
						}
					});
				}
				
			// Start checking once scripts are loaded
			checkAndInit();
		})();
	</script>
	<script is:inline>
		// Animate displacement filter scale: flickering at top, exponential scroll-based below
		document.addEventListener('DOMContentLoaded', () => {
			const displacementMap = document.getElementById('displacement');
			if (!displacementMap) return;
			
			const minScale = 10;
			const maxScale = 500;
			const exponent = 0.7; // Exponential curve (higher = more exponential growth)
			const flickerMin = 0;
			const flickerMax = 10;
			const flickerSpeed = 50; // Milliseconds between flicker updates during flicker phase
			const minFlickerDuration = 200; // Minimum milliseconds to flicker
			const maxFlickerDuration = 800; // Maximum milliseconds to flicker
			const minStillDuration = 500; // Minimum milliseconds to be still
			const maxStillDuration = 2000; // Maximum milliseconds to be still
			
			let flickerAnimationId = null;
			let isFlickering = false;
			let isFlickerPhase = false; // true = flickering, false = still
			let flickerStartTime = 0;
			let flickerDuration = 0;
			
			function startFlickering() {
				if (isFlickering) return;
				isFlickering = true;
				isFlickerPhase = true; // Start with flickering
				flickerStartTime = 0; // Reset timing
				
				function flickerLoop() {
					if (!isFlickering) return;
					
					const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
					// Only flicker if we're at the very top
					if (scrollTop !== 0) {
						isFlickering = false;
						return;
					}
					
					if (isFlickerPhase) {
						// Flickering phase: rapidly change values
						const randomScale = flickerMin + Math.random() * (flickerMax - flickerMin);
						displacementMap.setAttribute('scale', randomScale.toFixed(2));
						
						// Check if we need to start a new flicker phase
						const now = Date.now();
						if (flickerStartTime === 0) {
							// Start new flicker phase
							flickerStartTime = now;
							flickerDuration = minFlickerDuration + Math.random() * (maxFlickerDuration - minFlickerDuration);
						}
						
						// Check if flicker phase should end
						if (now - flickerStartTime >= flickerDuration) {
							// Switch to still phase
							isFlickerPhase = false;
							flickerStartTime = 0;
							displacementMap.setAttribute('scale', flickerMin.toFixed(2));
							
							// Stay still for a random duration
							const stillDuration = minStillDuration + Math.random() * (maxStillDuration - minStillDuration);
							flickerAnimationId = setTimeout(() => {
								// Switch back to flickering phase
								isFlickerPhase = true;
								flickerStartTime = 0;
								flickerLoop();
							}, stillDuration);
						} else {
							// Continue flickering
							flickerAnimationId = setTimeout(flickerLoop, flickerSpeed);
						}
					}
				}
				
				flickerLoop();
			}
			
			function stopFlickering() {
				isFlickering = false;
				if (flickerAnimationId) {
					clearTimeout(flickerAnimationId);
					flickerAnimationId = null;
				}
			}
			
			function updateScale() {
				const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
				const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
				
				// Calculate scroll progress (0 to 1)
				const scrollProgress = Math.min(Math.max(scrollTop / documentHeight, 0), 1);
				
				// If at the top, use flickering effect
				if (scrollTop === 0) {
					startFlickering();
					return; // Flickering function will handle the update
				} else {
					stopFlickering();
					
					// Apply exponential curve: scale increases exponentially as you scroll down
					const exponentialProgress = Math.pow(scrollProgress, exponent);
					const scale = minScale + (maxScale - minScale) * exponentialProgress;
					
					// Update the scale attribute
					displacementMap.setAttribute('scale', scale.toFixed(2));
				}
			}
			
			window.addEventListener('scroll', updateScale);
			updateScale(); // Initial call
		});
	</script>
		<Footer />
	</body>
</html>
